"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/middleware/index.ts
var middleware_exports = {};
__export(middleware_exports, {
  withMiddlewareAuth: () => withMiddlewareAuth
});
module.exports = __toCommonJS(middleware_exports);

// src/middleware/withMiddlewareAuth.ts
var import_server = require("next/server");
var import_auth_helpers_shared = require("@supabase/auth-helpers-shared");

// src/constants.ts
var PKG_NAME = "@supabase/auth-helpers-nextjs";
var PKG_VERSION = "0.4.4";

// src/middleware/withMiddlewareAuth.ts
var NoPermissionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NoPermissionError";
  }
};
var withMiddlewareAuth = (options = {}) => async (req) => {
  var _a;
  try {
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
      throw new Error(
        "NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!"
      );
    }
    const res = import_server.NextResponse.next();
    const supabase = (0, import_auth_helpers_shared.createServerSupabaseClient)({
      supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
      supabaseKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
      getCookie(name) {
        var _a2;
        const cookies = (0, import_auth_helpers_shared.parseCookies)((_a2 = req.headers.get("cookie")) != null ? _a2 : "");
        return cookies[name];
      },
      setCookie(name, value, options2) {
        const newSessionStr = (0, import_auth_helpers_shared.serializeCookie)(name, value, {
          ...options2,
          httpOnly: false
        });
        res.headers.append(name, newSessionStr);
      },
      getRequestHeader: (key) => {
        var _a2;
        const header = (_a2 = res.headers.get(key)) != null ? _a2 : void 0;
        return header;
      },
      options: {
        global: {
          headers: {
            "X-Client-Info": `${PKG_NAME}@${PKG_VERSION}`
          }
        }
      },
      cookieOptions: options.cookieOptions
    });
    const {
      data: { session },
      error
    } = await supabase.auth.getSession();
    if (error) {
      throw new Error(
        `Authorization error, redirecting to login page: ${error.message}`
      );
    } else if (!session) {
      throw new Error("No auth session, redirecting");
    } else if (options.authGuard && !await options.authGuard.isPermitted(session.user, supabase)) {
      throw new NoPermissionError("User is not permitted, redirecting");
    }
    return res;
  } catch (err) {
    let { redirectTo = "/" } = options;
    if (err instanceof NoPermissionError && !!((_a = options == null ? void 0 : options.authGuard) == null ? void 0 : _a.redirectTo)) {
      redirectTo = options.authGuard.redirectTo;
    }
    if (err instanceof Error) {
      console.log(
        `Could not authenticate request, redirecting to ${redirectTo}:`,
        err
      );
    }
    const redirectUrl = req.nextUrl.clone();
    redirectUrl.pathname = redirectTo;
    redirectUrl.searchParams.set(`redirectedFrom`, req.nextUrl.pathname);
    return import_server.NextResponse.redirect(redirectUrl);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  withMiddlewareAuth
});
//# sourceMappingURL=index.js.map