"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createBrowserSupabaseClient: () => createBrowserSupabaseClient,
  createServerSupabaseClient: () => createServerSupabaseClient4,
  logger: () => log_default,
  withApiAuth: () => withApiAuth,
  withMiddlewareAuth: () => withMiddlewareAuth,
  withPageAuth: () => withPageAuth
});
module.exports = __toCommonJS(src_exports);
var import_auth_helpers_shared4 = require("@supabase/auth-helpers-shared");

// src/constants.ts
var PKG_NAME = "@supabase/auth-helpers-nextjs";
var PKG_VERSION = "0.4.4";

// src/middleware/withMiddlewareAuth.ts
var import_server = require("next/server");
var import_auth_helpers_shared = require("@supabase/auth-helpers-shared");
var NoPermissionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NoPermissionError";
  }
};
var withMiddlewareAuth = (options = {}) => async (req) => {
  var _a;
  try {
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
      throw new Error(
        "NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!"
      );
    }
    const res = import_server.NextResponse.next();
    const supabase = (0, import_auth_helpers_shared.createServerSupabaseClient)({
      supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
      supabaseKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
      getCookie(name) {
        var _a2;
        const cookies = (0, import_auth_helpers_shared.parseCookies)((_a2 = req.headers.get("cookie")) != null ? _a2 : "");
        return cookies[name];
      },
      setCookie(name, value, options2) {
        const newSessionStr = (0, import_auth_helpers_shared.serializeCookie)(name, value, {
          ...options2,
          httpOnly: false
        });
        res.headers.append(name, newSessionStr);
      },
      getRequestHeader: (key) => {
        var _a2;
        const header = (_a2 = res.headers.get(key)) != null ? _a2 : void 0;
        return header;
      },
      options: {
        global: {
          headers: {
            "X-Client-Info": `${PKG_NAME}@${PKG_VERSION}`
          }
        }
      },
      cookieOptions: options.cookieOptions
    });
    const {
      data: { session },
      error
    } = await supabase.auth.getSession();
    if (error) {
      throw new Error(
        `Authorization error, redirecting to login page: ${error.message}`
      );
    } else if (!session) {
      throw new Error("No auth session, redirecting");
    } else if (options.authGuard && !await options.authGuard.isPermitted(session.user, supabase)) {
      throw new NoPermissionError("User is not permitted, redirecting");
    }
    return res;
  } catch (err) {
    let { redirectTo = "/" } = options;
    if (err instanceof NoPermissionError && !!((_a = options == null ? void 0 : options.authGuard) == null ? void 0 : _a.redirectTo)) {
      redirectTo = options.authGuard.redirectTo;
    }
    if (err instanceof Error) {
      console.log(
        `Could not authenticate request, redirecting to ${redirectTo}:`,
        err
      );
    }
    const redirectUrl = req.nextUrl.clone();
    redirectUrl.pathname = redirectTo;
    redirectUrl.searchParams.set(`redirectedFrom`, req.nextUrl.pathname);
    return import_server.NextResponse.redirect(redirectUrl);
  }
};

// src/utils/withPageAuth.ts
var import_auth_helpers_shared2 = require("@supabase/auth-helpers-shared");
function withPageAuth({
  authRequired = true,
  redirectTo = "/",
  getServerSideProps = void 0,
  cookieOptions = {}
} = {}) {
  return async (context) => {
    var _a;
    try {
      if (!context.req.cookies) {
        throw new import_auth_helpers_shared2.CookieNotParsed();
      }
      if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
        throw new Error(
          "NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!"
        );
      }
      const supabase = (0, import_auth_helpers_shared2.createServerSupabaseClient)({
        supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
        supabaseKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
        getRequestHeader: (key) => context.req.headers[key],
        getCookie(name) {
          return context.req.cookies[name];
        },
        setCookie(name, value, options) {
          var _a2, _b;
          const newSetCookies = (0, import_auth_helpers_shared2.filterCookies)(
            (0, import_auth_helpers_shared2.ensureArray)((_b = (_a2 = context.res.getHeader("set-cookie")) == null ? void 0 : _a2.toString()) != null ? _b : []),
            name
          );
          const newSessionStr = (0, import_auth_helpers_shared2.serializeCookie)(name, value, {
            ...options,
            httpOnly: false
          });
          context.res.setHeader("set-cookie", [
            ...newSetCookies,
            newSessionStr
          ]);
        },
        options: {
          global: {
            headers: {
              "X-Client-Info": `${PKG_NAME}@${PKG_VERSION}`
            }
          }
        },
        cookieOptions
      });
      const {
        data: { session },
        error
      } = await supabase.auth.getSession();
      if (error) {
        throw error;
      }
      if (authRequired && !session) {
        throw new import_auth_helpers_shared2.AuthHelperError("Unauthenticated", "unauthenticated");
      }
      let ret = { props: {} };
      if (getServerSideProps) {
        try {
          ret = await getServerSideProps(context, supabase);
        } catch (error2) {
          ret = {
            props: {
              error: String(error2)
            }
          };
        }
      }
      return {
        ...ret,
        props: {
          initialSession: session,
          user: (_a = session == null ? void 0 : session.user) != null ? _a : null,
          ...ret.props
        }
      };
    } catch (e) {
      if (authRequired) {
        return {
          redirect: {
            destination: redirectTo,
            permanent: false
          }
        };
      }
      return { props: {} };
    }
  };
}

// src/utils/withApiAuth.ts
var import_auth_helpers_shared3 = require("@supabase/auth-helpers-shared");
function withApiAuth(handler, options = {}) {
  return async (req, res) => {
    try {
      if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
        throw new Error(
          "NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!"
        );
      }
      const supabase = (0, import_auth_helpers_shared3.createServerSupabaseClient)({
        supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
        supabaseKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
        getCookie(name) {
          return req.cookies[name];
        },
        setCookie(name, value, options2) {
          var _a, _b;
          const newSetCookies = (0, import_auth_helpers_shared3.filterCookies)(
            (0, import_auth_helpers_shared3.ensureArray)((_b = (_a = res.getHeader("set-cookie")) == null ? void 0 : _a.toString()) != null ? _b : []),
            name
          );
          const newSessionStr = (0, import_auth_helpers_shared3.serializeCookie)(name, value, {
            ...options2,
            httpOnly: false
          });
          res.setHeader("set-cookie", [...newSetCookies, newSessionStr]);
        },
        getRequestHeader: (key) => {
          const header = res.getHeader(key);
          if (typeof header === "number") {
            return String(header);
          }
          return header;
        },
        options: {
          global: {
            headers: {
              "X-Client-Info": `${PKG_NAME}@${PKG_VERSION}`
            }
          }
        },
        cookieOptions: options.cookieOptions
      });
      const {
        data: { session },
        error
      } = await supabase.auth.getSession();
      if (error) {
        throw error;
      }
      if (!session)
        throw new import_auth_helpers_shared3.AuthHelperError("Unauthenticated", "unauthenticated");
      try {
        await handler(req, res, supabase);
      } catch (error2) {
        res.status(500).json({
          error: String(error2)
        });
        return;
      }
    } catch (error) {
      res.status(401).json({
        error: "not_authenticated",
        description: "The user does not have an active session or is not authenticated"
      });
      return;
    }
  };
}

// src/utils/log.ts
var dev = process.env.NODE_ENV !== "production";
var logger = {
  log: (message, ...optionalParams) => {
    dev ? console.log(message, ...optionalParams) : null;
  },
  error: (message, ...optionalParams) => {
    console.error(message, ...optionalParams);
  },
  info: (message, ...optionalParams) => {
    logger.log(message, ...optionalParams);
  },
  debug: (message, ...optionalParams) => {
    logger.log(message, ...optionalParams);
  },
  warn: (message, ...optionalParams) => {
    dev ? logger.error(message, ...optionalParams) : null;
  }
};
var log_default = logger;

// src/index.ts
function createBrowserSupabaseClient({
  cookieOptions
} = {}) {
  if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
    throw new Error(
      "NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!"
    );
  }
  return (0, import_auth_helpers_shared4.createBrowserSupabaseClient)({
    supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
    supabaseKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    cookieOptions
  });
}
function createServerSupabaseClient4(context, {
  cookieOptions
} = {}) {
  if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
    throw new Error(
      "NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables are required!"
    );
  }
  return (0, import_auth_helpers_shared4.createServerSupabaseClient)({
    supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL,
    supabaseKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    getRequestHeader: (key) => context.req.headers[key],
    getCookie(name) {
      return context.req.cookies[name];
    },
    setCookie(name, value, options) {
      var _a, _b;
      const newSetCookies = (0, import_auth_helpers_shared4.filterCookies)(
        (0, import_auth_helpers_shared4.ensureArray)((_b = (_a = context.res.getHeader("set-cookie")) == null ? void 0 : _a.toString()) != null ? _b : []),
        name
      );
      const newSessionStr = (0, import_auth_helpers_shared4.serializeCookie)(name, value, {
        ...options,
        httpOnly: false
      });
      context.res.setHeader("set-cookie", [...newSetCookies, newSessionStr]);
    },
    options: {
      global: {
        headers: {
          "X-Client-Info": `${PKG_NAME}@${PKG_VERSION}`
        }
      }
    },
    cookieOptions
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createBrowserSupabaseClient,
  createServerSupabaseClient,
  logger,
  withApiAuth,
  withMiddlewareAuth,
  withPageAuth
});
//# sourceMappingURL=index.js.map